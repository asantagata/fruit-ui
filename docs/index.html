<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FRUIT</title>
</head>
<body>
    <div id="sidebar"></div>
    <article id="article">
        <h1>The <i>Functional-Reactivity UI Toolkit</i> (FRUIT)</h1>
        <h2>What is FRUIT?</h2>
        <p>FRUIT is a lightweight, zero-dependency UI framework written in JavaScript for JavaScript apps. It uses nested JavaScript objects to represent DOM elements, i.e.,</p>
        <pre data-ref="writing-in-fruit-is-fun"></pre>
        <p>FRUIT is powerful, efficient, and feature-packed. In addition to objects representing static elements, users can write stateful, reactive components, i.e.,</p>
        <pre data-ref="counter"></pre>
        <p>FRUIT's features include:</p>
        <ul>
            <li>Intuitive element and component syntax</li>
            <li>Implicit props-passing between components</li>
            <li>Preserved, optionally reactive state</li>
            <li>Smooth, efficient rerendering with support for transitions and animations</li>
            <li>Keys to preserve state among re-ordered siblings</li>
            <li>An on-mount listener and handler methods</li>
            <li>Bindings to elements within components</li>
        </ul>
        <p>with all special functional features (state, controlled rerendering, bindings) accessed through the <code>this</code> argument.</p>
        <h2>Why use FRUIT over other front-end frameworks?</h2>
        <p>Smaller apps don't always warrant large, complex frameworks, but interfacing with the DOM directly is a hassle. The ability to declare and mutate state reactively is crucial in web apps with any amount of interactivity. Working in FRUIT and vanilla JS means no complex hidden logic to keep track of, no build step, and no separation of languages for your UI and your internal logic.</p>
    </article>
</body>
<script src="./components.js"></script>
<script type="module">
    import { replaceWith } from "https://cdn.jsdelivr.net/gh/asantagata/fruit-ui/dist/fruit.js";

    replaceWith(document.getElementById('sidebar'), sidebar);

    const SNIPPETS = {
        "writing-in-fruit-is-fun": {
            code: `import { appendChild } from "fruitui";

const Paragraph = {
    tag: 'p',
    children: [
        'Writing in ',
        {tag: 'strong', style: {color: 'blue'}, children: 'FRUIT'},
        ' is fun!'
    ]
};

// to append an element to the DOM
appendChild(document.body, Paragraph);`,
            result: ''
        },
        "counter": {
            code: `import { appendChild } from "fruitui";

const Counter = {
    state() {
        return {i: 0}; // initialize state
    },
    render() {
        return {
            tag: 'button',
            children: \`I've been clicked \${this.state.i} times!\`,
            on: {
                click() {
                    this.setState.i(i + 1);
                }
            }
        }
    }
}
    
appendChild(document.body, Counter);`,
            result: ''
        }
    };

    Array.from(article.getElementsByTagName('pre')).forEach(pre => {
        console.log(SNIPPETS[pre.dataset.ref]);
        const codeblock = Codeblock(SNIPPETS[pre.dataset.ref]);
        console.log(codeblock);
        replaceWith(pre, codeblock);
    });
</script>
</html>